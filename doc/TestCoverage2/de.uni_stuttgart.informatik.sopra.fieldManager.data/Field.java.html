<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Field.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">de.uni_stuttgart.informatik.sopra.fieldManager.data</a> &gt; <span class="el_source">Field.java</span></div><h1>Field.java</h1><pre class="source lang-java linenums">package de.uni_stuttgart.informatik.sopra.fieldManager.data;

import android.content.Context;
import android.location.Address;
import android.location.Geocoder;
import android.os.AsyncTask;

import org.osmdroid.util.GeoPoint;

import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Queue;

import de.uni_stuttgart.informatik.sopra.fieldManager.R;
import de.uni_stuttgart.informatik.sopra.fieldManager.data.FieldTypes.FieldType;
import de.uni_stuttgart.informatik.sopra.fieldManager.data.geoData.Triangle;

/**
 * Created by larsb on 22.11.2017.
 * &lt;p&gt;
 * this class is used to generate custom fields containing differnt arguments
 * and several utility methods
 */

public abstract class Field implements Serializable {
    private static final String TAG = &quot;Field&quot;;
    private static final long serialVersionUID = 11L;

    protected transient Context context;

    //values for field and damage case
    private long ID;
<span class="fc" id="L37">    private String name = &quot;&quot;;</span>
    private FieldType type;
<span class="fc" id="L39">    private String county = &quot;&quot;;</span>
    private int color;
    private double size;

<span class="fc" id="L43">    private String conSize = &quot;&quot;;</span>

<span class="fc" id="L45">    private List&lt;CornerPoint&gt; cornerPoints = new ArrayList&lt;&gt;();</span>

    /**
     * the rotation of the polygon
     * true if counterclockwise
     */
<span class="fc" id="L51">    private boolean rotation = false;</span>

<span class="fc" id="L53">    private boolean finished = false;</span>

    /**
     * constructor only used in custom Field classes via super()
     *
     * @param context
     * @param cPoints
     */
<span class="fc" id="L61">    public Field(Context context, List&lt;CornerPoint&gt; cPoints) {</span>
<span class="fc" id="L62">        this.context = context;</span>
<span class="fc" id="L63">        this.size = 0.0;</span>
<span class="fc" id="L64">        this.color = R.color.fieldDefaultColor;</span>

<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (cPoints.size() &lt; 2) {</span>
        } else {
<span class="fc" id="L68">            setCornerPoints(cPoints);</span>
<span class="fc" id="L69">            finish();</span>
        }
<span class="fc" id="L71">    }</span>

    /**
     * add a corner point to the field
     *
     * @param cp
     */
    public void addCornerPoint(CornerPoint cp) {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (cornerPoints.size() == 1) {</span>
<span class="fc" id="L80">            setAutomaticCounty();</span>
        }
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (!finished) {</span>
<span class="fc" id="L83">            cornerPoints.add(cp);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (cornerPoints.size() &gt; 2) {</span>
<span class="fc" id="L85">                cornerPoints.get(cornerPoints.size() - 2).calculateAngle(cornerPoints.get(cornerPoints.size() - 3), cp);</span>
            }
        }
<span class="fc" id="L88">    }</span>

    /**
     * only used if there will be no corner points added anymore
     */
    public void finish() {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (cornerPoints.size() &gt; 2) {</span>
<span class="fc" id="L95">            cornerPoints.get(cornerPoints.size() - 1).calculateAngle(cornerPoints.get(cornerPoints.size() - 2), cornerPoints.get(0));</span>
<span class="fc" id="L96">            cornerPoints.get(0).calculateAngle(cornerPoints.get(cornerPoints.size() - 1), cornerPoints.get(1));</span>
<span class="fc" id="L97">            calculateSize();</span>
<span class="fc" id="L98">            convertSize();</span>
<span class="fc" id="L99">            finished = true;</span>
        }
<span class="fc" id="L101">    }</span>

    /**
     * calculate the size of the polygon
     */
    private void calculateSize() {
<span class="fc" id="L107">        size = 0;</span>
<span class="fc" id="L108">        List&lt;CornerPoint&gt; rmCopy = new ArrayList&lt;&gt;(cornerPoints);</span>

<span class="fc" id="L110">        Queue&lt;CornerPoint&gt; outwardPoints = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L111">        List&lt;Triangle&gt; triangleList = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (angleSum()) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (CornerPoint cp : cornerPoints) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                if (angleCheck(cp.getAngle())) {</span>
<span class="nc" id="L116">                    outwardPoints.add(cp);</span>
                }
<span class="fc" id="L118">            }</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            for (int i = 0; i &lt; cornerPoints.size() - 2; i++) {</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">                if (outwardPoints.isEmpty()) {</span>
<span class="fc" id="L121">                    triangleList.add(new Triangle(rmCopy.get(0), rmCopy.get(1), rmCopy.get(2)));</span>
<span class="fc" id="L122">                    rmCopy.remove(1);</span>
                } else {
<span class="nc" id="L124">                    CornerPoint cp = outwardPoints.poll();</span>
<span class="nc" id="L125">                    int index = rmCopy.indexOf(cp);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                    int indexBefore = ((index != 0) ? index - 1 : rmCopy.size() - 1);</span>

                    //two outward Points following
<span class="nc bnc" id="L129" title="All 2 branches missed.">                    if (angleCheck(rmCopy.get(indexBefore).getAngle())) {</span>
<span class="nc" id="L130">                        i--;</span>
<span class="nc" id="L131">                        outwardPoints.add(cp);</span>
                    } else {
<span class="nc bnc" id="L133" title="All 2 branches missed.">                        int indexTwoBefore = ((indexBefore != 0) ? indexBefore - 1 : rmCopy.size() - 1);</span>
                        //make triangle
<span class="nc" id="L135">                        triangleList.add(new Triangle(rmCopy.get(indexTwoBefore), rmCopy.get(indexBefore), rmCopy.get(index)));</span>
<span class="nc" id="L136">                        rmCopy.remove(indexBefore);</span>

                        //recalculate angles
<span class="nc" id="L139">                        index = rmCopy.indexOf(cp);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                        indexBefore = ((index != 0) ? index - 1 : rmCopy.size() - 1);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                        int indexAfter = ((index == rmCopy.size() - 1) ? 0 : ++index);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                        indexTwoBefore = ((indexBefore != 0) ? indexBefore - 1 : rmCopy.size() - 1);</span>
<span class="nc" id="L143">                        CornerPoint cpBefore = rmCopy.get(indexBefore);</span>
<span class="nc" id="L144">                        cp.calculateAngle(cpBefore, rmCopy.get(indexAfter));</span>
<span class="nc" id="L145">                        cpBefore.calculateAngle(rmCopy.get(indexTwoBefore), cp);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                        if (angleCheck(cp.getAngle())) {</span>
<span class="nc" id="L147">                            outwardPoints.add(cp);</span>
                        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">                        if (angleCheck(cpBefore.getAngle())) {</span>
<span class="nc" id="L150">                            outwardPoints.add(cpBefore);</span>
                        }
                    }
                }
            }
<span class="fc bfc" id="L155" title="All 2 branches covered.">            for (Triangle t : triangleList) {</span>
<span class="fc" id="L156">                size += t.getSize();</span>
<span class="fc" id="L157">            }</span>
        }
<span class="fc" id="L159">    }</span>

    /*
     * Convert the size of the field in a readable format
     */
    private void convertSize() {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (this.size &gt; 1000000) {</span>
<span class="nc" id="L166">            this.conSize = (String.valueOf(size / 1000000)) + &quot;km&quot; + &quot;\u00B2&quot;;</span>
<span class="pc bpc" id="L167" title="1 of 4 branches missed.">        } else if (this.size &gt; 10000 &amp;&amp; this.size &lt;= 1000000) {</span>
<span class="fc" id="L168">            this.conSize = (String.valueOf(size / 10000)) + &quot;ha&quot;;</span>
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">        } else if (this.size &gt; 100 &amp;&amp; this.size &lt;= 10000) {</span>
<span class="fc" id="L170">            this.conSize = (String.valueOf(size / 100)) + &quot;a&quot;;</span>
        } else {
<span class="nc" id="L172">            this.conSize = (String.valueOf(size)) + &quot;m&quot; + &quot;\u00B2&quot;;</span>
        }
<span class="fc" id="L174">    }</span>

    /**
     * check if angles are okay
     *
     * @param angle
     * @return
     */
    private boolean angleCheck(double angle) {
<span class="pc bpc" id="L183" title="2 of 6 branches missed.">        return rotation ? angle &lt;= Math.PI : angle &gt;= Math.PI;</span>
    }

    /**
     * calculate angle sum, might be wrong
     *
     * @return
     */
    private boolean angleSum() {
<span class="fc" id="L192">        double sum = 0;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (int i = 0; i &lt; cornerPoints.size(); i++) {</span>
<span class="fc" id="L194">            sum += cornerPoints.get(i).getAngle();</span>
        }
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (Math.abs(sum - (Math.PI * (cornerPoints.size() + 2))) &lt; 0.001) {</span>
<span class="fc" id="L197">            rotation = true;</span>
<span class="fc" id="L198">            return true;</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        } else if (Math.abs(sum - (Math.PI * (cornerPoints.size() - 2))) &lt; 0.001) {</span>
<span class="fc" id="L200">            return true;</span>
        } else {
            //either wrong calculation or crossing lines in input polygon
<span class="nc" id="L203">            return false;</span>
        }
    }

    /**
     * calculate centroid ( = center of gravity) of polygon
     */
    public GeoPoint calculateCentroid() {
        double lowX0, lowY0, highX1, highY1;

<span class="fc" id="L213">        lowX0 = lowY0 = Double.MAX_VALUE;</span>
<span class="fc" id="L214">        highX1 = highY1 = Double.MIN_VALUE;</span>

<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (CornerPoint point : getCornerPoints()) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            if (lowX0 &gt; point.getWGS().getLatitude()) {</span>
<span class="fc" id="L218">                lowX0 = point.getWGS().getLatitude();</span>
            }
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (lowY0 &gt; point.getWGS().getLongitude()) {</span>
<span class="fc" id="L221">                lowY0 = point.getWGS().getLongitude();</span>
            }
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (highX1 &lt; point.getWGS().getLatitude()) {</span>
<span class="fc" id="L224">                highX1 = point.getWGS().getLatitude();</span>
            }
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (highY1 &lt; point.getWGS().getLongitude()) {</span>
<span class="fc" id="L227">                highY1 = point.getWGS().getLongitude();</span>
            }
<span class="fc" id="L229">        }</span>

<span class="fc" id="L231">        return new GeoPoint(lowX0 + ((highX1 - lowX0) / 2), lowY0 + ((highY1 - lowY0) / 2));</span>
    }

    /**
     * returns the size of this field in m^2
     *
     * @return the size of the field or 0 if the field isn't finished
     */
    public double getSize() {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        return finished ? size : 0;</span>
    }

    public void setCornerPoints(List&lt;CornerPoint&gt; cornerPoints) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (CornerPoint cp : cornerPoints) {</span>
<span class="fc" id="L245">            addCornerPoint(cp);</span>
<span class="fc" id="L246">        }</span>
<span class="fc" id="L247">    }</span>

    public List&lt;CornerPoint&gt; getCornerPoints() {
<span class="fc" id="L250">        return cornerPoints;</span>
    }

    public GeoPoint getCentroid() {
<span class="fc" id="L254">        return calculateCentroid();</span>
    }

    public String getName() {
<span class="fc" id="L258">        return name;</span>
    }

    public void setName(String name) {
<span class="fc" id="L262">        this.name = name;</span>
<span class="fc" id="L263">    }</span>

    public String getCounty() {
<span class="fc" id="L266">        return county;</span>
    }

    public void setCounty(String county) {
<span class="fc" id="L270">        this.county = county;</span>
<span class="fc" id="L271">    }</span>

    public int getColor() {
<span class="fc" id="L274">        return color;</span>
    }

    protected void setColor(int color) {
<span class="fc" id="L278">        this.color = color;</span>
<span class="fc" id="L279">    }</span>

    public void setContext(Context context) {
<span class="nc" id="L282">        this.context = context;</span>
<span class="nc" id="L283">    }</span>

    public String getConvertedSize() {
<span class="fc" id="L286">        return conSize;</span>
    }

    public FieldType getType() {
<span class="fc" id="L290">        return type;</span>
    }

    /**
     * sets the Field type and the color
     *
     * @param type
     */
    public void setType(FieldType type) {
<span class="fc" id="L299">        this.type = type;</span>
<span class="fc" id="L300">        this.setColor(type.toColor());</span>
<span class="fc" id="L301">    }</span>

    public boolean isFieldequal(Field otherField) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">        return otherField.getID() == this.getID();</span>
    }

    /**
     * starts an async task that tries to get the SubAdminArea
     * by reverse geocoding the first corner point of this field
     * might take a bit, thats why its async -FB
     */
    public void setAutomaticCounty() {
<span class="fc" id="L313">        new AsyncReverseGeoCoding().execute(new double[]{</span>
<span class="fc" id="L314">                this.getCornerPoints().get(0).getWGS().getLatitude(),</span>
<span class="fc" id="L315">                this.getCornerPoints().get(0).getWGS().getLongitude()</span>
        });
<span class="fc" id="L317">    }</span>

    public long getID() {
<span class="fc" id="L320">        return ID;</span>
    }

    public void setID(long ID) {
<span class="fc" id="L324">        this.ID = ID;</span>
<span class="fc" id="L325">    }</span>

    /**
     * google asks its servers for reverse geo coding, this might take some time
     * especially for 100+ fields
     * try to call this only if necessary! -FB
     */
<span class="fc" id="L332">    private class AsyncReverseGeoCoding extends AsyncTask&lt;double[], Void, String&gt; {</span>

        @Override
        protected String doInBackground(double[]... doubles) {
            //async task is weird.. TODO change this
<span class="fc" id="L337">            setCountyAddress(doubles[0][0], doubles[0][1]);</span>
<span class="fc" id="L338">            return null;</span>
        }

        @Override
        protected void onPostExecute(String result) {
<span class="fc" id="L343">        }</span>

        @Override
        protected void onPreExecute() {
<span class="fc" id="L347">        }</span>

        @Override
        protected void onProgressUpdate(Void... values) {
<span class="nc" id="L351">        }</span>

        private void setCountyAddress(double lat, double lon) {
            //uses the google geocoder, might be a part of the google maps api.. or not -FB
<span class="fc" id="L355">            Geocoder geocoder = new Geocoder(context, Locale.getDefault());</span>
<span class="fc" id="L356">            List&lt;Address&gt; addresses = null;</span>
            try {
<span class="fc" id="L358">                addresses = geocoder.getFromLocation(lat, lon, 1);</span>

<span class="pc bpc" id="L360" title="2 of 4 branches missed.">                if (addresses != null &amp;&amp; !addresses.isEmpty()) {</span>
<span class="fc" id="L361">                    setCounty(&quot;Adress: &quot;); //remove &quot;loading...&quot;</span>
<span class="fc" id="L362">                    String county = &quot;&quot;;</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                    for (int i = 0; i &lt;= addresses.get(0).getMaxAddressLineIndex(); i++) {</span>
<span class="fc" id="L364">                        county += &quot; &quot; + addresses.get(0).getAddressLine(i);</span>
                    }
<span class="fc" id="L366">                    setCounty(county);</span>
<span class="fc" id="L367">                } else {</span>
<span class="nc" id="L368">                    setCounty(&quot;No Location Set&quot;);</span>
                }
<span class="nc" id="L370">            } catch (IOException ignored) {</span>
<span class="nc" id="L371">                ignored.printStackTrace();</span>
<span class="fc" id="L372">            }</span>
<span class="fc" id="L373">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span>Generated by the Android Gradle plugin 3.0.1</div></body></html>