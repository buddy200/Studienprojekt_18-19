<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CornerPoint.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">de.uni_stuttgart.informatik.sopra.fieldManager.data</a> &gt; <span class="el_source">CornerPoint.java</span></div><h1>CornerPoint.java</h1><pre class="source lang-java linenums">package de.uni_stuttgart.informatik.sopra.fieldManager.data;

import java.io.Serializable;

import de.uni_stuttgart.informatik.sopra.fieldManager.data.geoData.MathUtility;
import de.uni_stuttgart.informatik.sopra.fieldManager.data.geoData.UTMCoordinate;
import de.uni_stuttgart.informatik.sopra.fieldManager.data.geoData.Vector;
import de.uni_stuttgart.informatik.sopra.fieldManager.data.geoData.WGS84Coordinate;
import de.uni_stuttgart.informatik.sopra.fieldManager.data.geoData.WGS84UTMConverter;

/**
 * Created by Christian on 13.11.2017.
 *
 * CornerPoints for Fields, these are the Points for our Polygons
 */

public class CornerPoint implements Serializable {

    private WGS84Coordinate wgs;
    private UTMCoordinate utm;

    /**
     * the angle at this cornerpoint
     * on the right side following the input path
     * as radian
     */
    private double angle;

    /**
     * constructor, we need latitude and longitude coordinates in WGS84 format
     * @param latitude
     * @param logitude
     */
<span class="fc" id="L34">    public CornerPoint(double latitude, double logitude) {</span>
<span class="pc bpc" id="L35" title="2 of 4 branches missed.">        if (latitude != Double.NaN &amp;&amp; logitude != Double.NaN) {</span>
<span class="fc" id="L36">            wgs = new WGS84Coordinate(latitude, logitude);</span>
<span class="fc" id="L37">            utm = WGS84UTMConverter.convert(wgs);</span>
        }
<span class="fc" id="L39">    }</span>

    /**
     * calculate the angle of two corner points
     * @param before the Cornerpoint infront of this Cornerpoint
     * @param after the Cornerpoint behind of this Cornerpoint
     */
    public void calculateAngle(CornerPoint before, CornerPoint after) {

<span class="fc" id="L48">        UTMCoordinate utmBefore = before.getUtm();</span>
<span class="fc" id="L49">        UTMCoordinate utmAfter = after.getUtm();</span>
        Vector v_before;
        Vector v_after;
<span class="fc" id="L52">        double centralMerdian = 3.0 + 6.0 * (this.utm.getZone() - 1.0) - 180.0;</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if(utm.getZone() == utmBefore.getZone()) {</span>
<span class="fc" id="L54">            v_before = new Vector((utmBefore.getEasting()- utm.getEasting()), (utmBefore.getNorthing()-utm.getNorthing()));</span>
        } else {
            double merdian;
<span class="nc bnc" id="L57" title="All 2 branches missed.">            if(utm.getZone() &lt; utmBefore.getZone()) {</span>
<span class="nc" id="L58">                merdian = centralMerdian + 3;</span>
            } else {
<span class="nc" id="L60">                merdian = centralMerdian - 3;</span>
            }
<span class="nc" id="L62">            double deltaLat = before.getWGS().getLatitude() - wgs.getLatitude();</span>
<span class="nc" id="L63">            double deltaLong = before.getWGS().getLongitude() - wgs.getLongitude();</span>

<span class="nc" id="L65">            double lat = deltaLat/deltaLong * (merdian - wgs.getLongitude()) + wgs.getLatitude();</span>

<span class="nc" id="L67">            UTMCoordinate utm = WGS84UTMConverter.getUtmCoordinateByMeridian(MathUtility.degToRad(lat),MathUtility.degToRad(merdian), centralMerdian);</span>
<span class="nc" id="L68">            v_before = new Vector((utm.getEasting()- this.utm.getEasting()), (utm.getNorthing()- this.utm.getNorthing()));</span>
        }

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if(utm.getZone() == utmAfter.getZone()) {</span>
<span class="fc" id="L72">            v_after = new Vector((utmAfter.getEasting()- utm.getEasting()), (utmAfter.getNorthing()-utm.getNorthing()));</span>
        } else {
            double merdian;
<span class="nc bnc" id="L75" title="All 2 branches missed.">            if(utm.getZone() &lt; utmAfter.getZone()) {</span>
<span class="nc" id="L76">                merdian = centralMerdian + 3;</span>
            } else {
<span class="nc" id="L78">                merdian = centralMerdian - 3;</span>
            }
<span class="nc" id="L80">            double deltaLat = after.getWGS().getLatitude() - wgs.getLatitude();</span>
<span class="nc" id="L81">            double deltaLong = after.getWGS().getLongitude() - wgs.getLongitude();</span>

<span class="nc" id="L83">            double lat = deltaLat/deltaLong * (merdian - wgs.getLongitude()) + wgs.getLatitude();</span>

<span class="nc" id="L85">            UTMCoordinate utm = WGS84UTMConverter.getUtmCoordinateByMeridian(MathUtility.degToRad(lat),MathUtility.degToRad(merdian), centralMerdian);</span>
<span class="nc" id="L86">            v_after = new Vector((utm.getEasting()- this.utm.getEasting()), (utm.getNorthing()- this.utm.getNorthing()));</span>
        }


<span class="fc bfc" id="L90" title="All 4 branches covered.">        if(v_before.getLength() == 0 || v_after.getLength() == 0) {</span>
<span class="fc" id="L91">            angle = 0;</span>
<span class="fc" id="L92">            return;</span>
        }
        //cos a = (v_a x v_b )/ (|v_a| * |v_b)|
<span class="fc" id="L95">        angle = Math.acos(MathUtility.scalarProduct(v_before,v_after)/(v_before.getLength() * v_after.getLength()));</span>

<span class="fc" id="L97">        Vector rotated = v_after.rotate(angle);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if(rotated.equalDirection(v_before)) {</span>
<span class="fc" id="L99">            angle = 2*Math.PI - angle;</span>
        }

<span class="fc" id="L102">    }</span>

    public WGS84Coordinate getWGS() {
<span class="fc" id="L105">        return wgs;</span>
    }

    public UTMCoordinate getUtm() {
<span class="fc" id="L109">        return utm;</span>
    }

    public double getAngle() {
<span class="fc" id="L113">        return angle;</span>
    }

    public void setUtm(UTMCoordinate utm) {
<span class="fc" id="L117">        this.utm = utm;</span>
<span class="fc" id="L118">    }</span>

    @Override
    public boolean equals(Object o ) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (o instanceof CornerPoint) {</span>
<span class="fc" id="L123">            return utm.equals( ((CornerPoint) o).getUtm());</span>
        } else {
<span class="fc" id="L125">            return false;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span>Generated by the Android Gradle plugin 3.0.1</div></body></html>